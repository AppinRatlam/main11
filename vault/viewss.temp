# # # from django.shortcuts import render, redirect, get_object_or_404
# # # from django.http import HttpResponse
# # # from django.contrib import messages
# # # from django.utils import timezone
# # # from django.db.models import Sum, Q
# # # from django.contrib.auth import authenticate, login, logout
# # # from django.contrib.auth.decorators import login_required
# # # import csv

# # # from .forms import IntakeForm
# # # from .models import Deposit
# # # from django.core.mail import send_mail


# # # # ---------- Authentication ----------
# # # def user_login(request):
# # #     if request.method == "POST":
# # #         username = request.POST.get('username')
# # #         password = request.POST.get('password')
# # #         user = authenticate(request, username=username, password=password)
# # #         if user is not None:
# # #             login(request, user)
# # #             return redirect('home')
# # #         else:
# # #             messages.error(request, "Invalid Username or Password")
# # #     return render(request, 'login.html')


# # # def user_logout(request):
# # #     logout(request)
# # #     return redirect('login')


# # # # ---------- Deposit Form ----------
# # # # 
# # # @login_required(login_url='/login/')
# # # def intake(request):
# # #     if request.method == 'POST':
# # #         form = IntakeForm(request.POST)
# # #         if form.is_valid():
# # #             # Store form data in session instead of saving to DB
# # #             request.session['pending_deposit'] = form.cleaned_data

# # #             # Redirect to OTP page
# # #             return redirect('otp')  # Your OTP view URL name
# # #     else:
# # #         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})

# # #     return render(request, 'vault/intake.html', {'form': form})

# # # # ---------- Home / Dashboard ----------
# # # def otp(request):
# # #     # Server will inject widgetId and tokenAuth dynamically
# # #     context = {
# # #         "widget_id": "356a6568356a343732333939",       # Keep this secret in settings or env
# # #         "token_auth": "472099TjSVarLM2l68e2193bP1"     # Keep this secret in settings or env
# # #     }
# # #     return render(request, "otp_page.html", context)

# # # @login_required(login_url='/login/')
# # # def otp_verify(request):
# # #     """
# # #     Called via AJAX after front-end OTP verification.
# # #     Saves deposit and generates token.
# # #     """
# # #     if request.method == "POST":
# # #         pending = request.session.get('pending_deposit')
# # #         if not pending:
# # #             return JsonResponse({"error": "No deposit data found."}, status=400)

# # #         # Save deposit
# # #         deposit = IntakeForm(pending).save(commit=False)
# # #         deposit.token = next_token(pending.get('diwali_year', timezone.localdate().year))
# # #         deposit.save()

# # #         # Clear session
# # #         del request.session['pending_deposit']

# # #         # Return JSON with redirect URL
# # #         return JsonResponse({"redirect_url": f"/receipt/{deposit.token}/"})
# # #     return JsonResponse({"error": "Invalid request."}, status=400)

# # # @login_required(login_url='/login/')
# # # def home(request):
# # #     total_held = Deposit.objects.filter(status='HELD').aggregate(total=Sum('amount'))['total'] or 0
# # #     total_returned = Deposit.objects.filter(status='RETURNED').aggregate(total=Sum('amount'))['total'] or 0
# # #     count_today = Deposit.objects.filter(received_at__date=timezone.localdate()).count()
# # #     return render(request, 'vault/home.html', {
# # #         'total_held': total_held,
# # #         'total_returned': total_returned,
# # #         'count_today': count_today,
# # #     })


# # # # ---------- Receipt ----------
# # # def receipt(request, token):
# # #     deposit = get_object_or_404(Deposit, token=token)
# # #     return render(request, 'vault/receipt.html', {'d': deposit})


# # # # ---------- Search ----------
# # # def search(request):
# # #     q = request.GET.get('q', '').strip()
# # #     results = []
# # #     if q:
# # #         results = Deposit.objects.select_related('devotee').filter(
# # #             Q(token__icontains=q) | Q(devotee__name__icontains=q) | Q(devotee__phone__icontains=q)
# # #         ).order_by('-received_at')[:50]
# # #     return render(request, 'vault/search.html', {'q': q, 'results': results})


# # # # ---------- Mark Returned ----------
# # # def mark_returned(request, token):
# # #     deposit = get_object_or_404(Deposit, token=token)
# # #     if request.method == 'POST':
# # #         deposit.status = 'RETURNED'
# # #         deposit.returned_at = timezone.now()
# # #         deposit.save()
# # #         messages.success(request, f'Returned: {deposit.token}')
# # #         return redirect('receipt', token=deposit.token)
# # #     return render(request, 'vault/mark_returned.html', {'d': deposit})


# # # # ---------- Report ----------
# # # def report(request):
# # #     year = request.GET.get('year')
# # #     status = request.GET.get('status')
# # #     qs = Deposit.objects.select_related('devotee').all().order_by('-received_at')
# # #     if year:
# # #         qs = qs.filter(diwali_year=year)
# # #     if status:
# # #         qs = qs.filter(status=status)

# # #     total_amount = qs.aggregate(total=Sum('amount'))['total'] or 0
# # #     total_count = qs.count()

# # #     return render(request, 'vault/report.html', {
# # #         'qs': qs[:500],
# # #         'year': year,
# # #         'status': status,
# # #         'total_amount': total_amount,
# # #         'total_count': total_count
# # #     })


# # # # ---------- Export CSV ----------
# # # def export_csv(request):
# # #     year = request.GET.get('year')
# # #     status = request.GET.get('status')
# # #     qs = Deposit.objects.select_related('devotee').all().order_by('token')
# # #     if year:
# # #         qs = qs.filter(diwali_year=year)
# # #     if status:
# # #         qs = qs.filter(status=status)

# # #     response = HttpResponse(content_type='text/csv')
# # #     response['Content-Disposition'] = 'attachment; filename="deposits.csv"'
# # #     writer = csv.writer(response)
# # #     writer.writerow(['Token', 'Name', 'Phone', 'Aadhaar Last4', 'Amount', 'Status',
# # #                      'Received At', 'Returned At', 'Year', 'Address', 'Comment',
# # #                      'Form Filler Name', 'Quantity'])
# # #     for d in qs:
# # #         writer.writerow([
# # #             d.token, d.devotee.name, d.devotee.phone, d.devotee.aadhaar_last4,
# # #             d.amount, d.status, d.received_at, d.returned_at, d.diwali_year,
# # #             d.devotee.address.replace('\n', ' '), d.comment_choice,
# # #             d.form_filler_name, d.quantity
# # #         ])
# # #     return response









# # # # from django.shortcuts import render, redirect, get_object_or_404
# # # # from django.http import HttpResponse
# # # # from django.contrib import messages
# # # # from django.utils import timezone
# # # # from django.db.models import Sum, Count, Q
# # # # from .forms import IntakeForm
# # # # from .models import Deposit
# # # # import csv
# # # # from django.contrib.auth import authenticate, login, logout

# # # # from django.core.mail import send_mail
# # # # from django.shortcuts import render, redirect
# # # # from django.contrib import messages
# # # # from .utils import generate_otp, send_otp_whatsapp, store_otp, verify_otp

# # # # from django.contrib.auth.decorators import login_required
# # # # from django.contrib.auth.decorators import login_required




# # # # def user_login(request):
# # # #     if request.method == "POST":
# # # #         username = request.POST.get('username')
# # # #         password = request.POST.get('password')
# # # #         user = authenticate(request, username=username, password=password)
# # # #         if user is not None:
# # # #             login(request, user)
# # # #             return redirect('home')
# # # #         else:
# # # #             messages.error(request, "Invalid Username or Password")
# # # #     return render(request, 'login.html')


# # # # def user_logout(request):
# # # #     logout(request)
# # # #     return redirect('login')

# # # # def deposit_send_otp(request):
# # # #     if request.method == "POST":
# # # #         phone = request.POST.get("phone")
# # # #         otp = generate_otp()
# # # #         if send_otp_whatsapp(phone, otp):
# # # #             store_otp(request, phone, otp)
# # # #             request.session["phone"] = phone
# # # #             messages.success(request, "OTP sent successfully!")
# # # #             return redirect("verify_otp")
# # # #         else:
# # # #             messages.error(request, "Failed to send OTP.")
# # # #     return render(request, "request_otp.html")


# # # # def deposit_verify_otp(request):
# # # #     phone = request.session.get("phone")  # phone stored when sending OTP
# # # #     if request.method == "POST":
# # # #         otp_input = request.POST.get("otp")
# # # #         if verify_otp(request, phone, otp_input):
# # # #             messages.success(request, "Phone verified successfully!")
# # # #             # Optionally, mark user as verified in database
# # # #             return redirect("home")
# # # #         else:
# # # #             messages.error(request, "Invalid OTP. Try again.")
# # # #     return render(request, "verify_otp.html")


# # # # def deposit_send_otp(request):
# # # #     if request.method == "POST":
# # # #         phone = request.POST.get("phone")
# # # #         otp_code = send_otp_whatsapp(phone, request=request)
# # # #         # Store phone and OTP status in session
# # # #         request.session['otp_phone'] = phone
# # # #         request.session['otp_sent'] = True
       
# # # #     return render(request, "send_otp.html")

# # # # def deposit_verify_otp(request):
# # # #     # Check if OTP was sent
# # # #     if not request.session.get('otp_sent'):
# # # #         return redirect('deposit_send_otp')  # redirect back if OTP not sent

# # # #     phone = request.session.get('otp_phone')
    
# # # #     if request.method == "POST":
# # # #         code = request.POST.get("otp")
# # # #         if verify_otp_whatsapp(phone, code, request=request):
# # # #             # OTP verified, clear session flags
# # # #             request.session['otp_verified'] = True
# # # #             request.session.pop('otp_sent', None)
# # # #             return render(request, "otp_success.html")
# # # #         else:
# # # #             return render(request, "verify_otp.html", {"phone": phone, "error": "Invalid OTP"})
    
# # # #     return render(request, "verify_otp.html", {"phone": phone})

# # # # def deposit_form(request):
# # # #     if not request.session.get('otp_verified'):
# # # #         return redirect('deposit_send_otp')  # force OTP first

# # # #     # Your normal deposit form logic here


# # # # @login_required(login_url='/login/')
# # # # def intake(request):
 
# # # #     if request.method == 'POST':
# # # #         form = IntakeForm(request.POST)
# # # #         if form.is_valid():
# # # #             # store cleaned_data in session (so we can re-create the form for saving)
# # # #             cleaned_data = form.cleaned_data.copy()
# # # #             # Convert Decimal to string so it can be JSON serializable
# # # #             if 'amount' in cleaned_data:
# # # #                 cleaned_data['amount'] = str(cleaned_data['amount'])
# # # #             if 'quantity' in cleaned_data:
# # # #                 cleaned_data['quantity'] = str(cleaned_data['quantity'])
# # # #             request.session['pending_deposit'] = cleaned_data

# # # #             phone = form.cleaned_data.get('phone')
# # # #             try:
# # # #                 send_otp(phone, request=request)  # Twilio or fallback
# # # #             except Exception as e:
# # # #                 # keep user informed; but still allow OTP fallback flow
# # # #                 print("OTP send error:", e)
# # # #                 messages.warning(request, "Unable to send OTP via provider ‚Äî using local OTP for testing.")
# # # #             return redirect('intake_verify')

# # # #     else:
# # # #         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})
# # # #     return render(request, 'vault/intake.html', {'form': form})


    
# # # # @login_required(login_url='/login/')
# # # # def intake_verify(request):
# # # #     """
# # # #     Page where the user enters OTP. If OTP OK -> recreate form with stored data and save deposit.
# # # #     """
# # # #     pending = request.session.get('pending_deposit')
# # # #     if not pending:
# # # #         messages.error(request, "No pending deposit found. Please fill the deposit form first.")
# # # #         return redirect('intake')

# # # #     phone = pending.get('phone')
# # # #     if request.method == 'POST':
# # # #         otp_code = request.POST.get('otp', '').strip()
# # # #         if verify_otp(phone, otp_code, request=request):
# # # #             # create & save deposit now
# # # #             form = IntakeForm(pending)
# # # #             if form.is_valid():
# # # #                 deposit = form.save()
# # # #                 # cleanup session
# # # #                 if deposit.devotee.email:   # make sure Devotee model has email field
# # # #                     try:
# # # #                         send_mail(
# # # #                             subject="Mahalakshmi Temple - Token Number",
# # # #                             message=f"Dear {deposit.devotee.name},\n\nYour token number is {deposit.token}.\n"
# # # #                                     f"Amount Deposited: ‚Çπ{deposit.amount}\n"
# # # #                                     f"Year: {deposit.diwali_year}\n\n"
# # # #                                     f"Please keep this safe. Jai Maa Mahalakshmi üôè",
# # # #                             from_email="your_email@gmail.com",  # temple email
# # # #                             recipient_list=[deposit.devotee.email],
# # # #                             fail_silently=True,
# # # #                         )
# # # #                     except Exception as e:
# # # #                         print("Email sending failed:", e)

# # # #                 try:
# # # #                     del request.session['pending_deposit']
# # # #                 except KeyError:
# # # #                     pass
# # # #                 try:
# # # #                     del request.session['pending_otp_code']
# # # #                 except KeyError:
# # # #                     pass
# # # #                 messages.success(request, f'Token generated: {deposit.token}')
# # # #                 return redirect('receipt', token=deposit.token)
# # # #             else:
# # # #                 # unexpected: session data should be valid
# # # #                 messages.error(request, "Saved form data invalid. Please try again.")
# # # #                 return redirect('intake')
# # # #         else:
# # # #             messages.error(request, "Invalid OTP. Please try again.")
# # # #     return render(request, 'vault/verify_otp.html', {'phone': phone})

# # # # @login_required(login_url='/login/')
# # # # def home(request):
# # # #     # Dashboard stats
# # # #     total_held = Deposit.objects.filter(status='HELD').aggregate(total=Sum('amount'))['total'] or 0
# # # #     total_returned = Deposit.objects.filter(status='RETURNED').aggregate(total=Sum('amount'))['total'] or 0
# # # #     count_today = Deposit.objects.filter(received_at__date=timezone.localdate()).count()
# # # #     return render(request, 'vault/home.html', {
# # # #         'total_held': total_held,
# # # #         'total_returned': total_returned,
# # # #         'count_today': count_today,
# # # #     })


# # # # # def intake(request):
# # # # #     if request.method == 'POST':
# # # # #         form = IntakeForm(request.POST)
# # # # #         if form.is_valid():
# # # # #             deposit = form.save()
# # # # #             messages.success(request, f'Token generated: {deposit.token}')
# # # # #             return redirect('receipt', token=deposit.token)
# # # # #     else:
# # # # #         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})
# # # # #     return render(request, 'vault/intake.html', {'form': form})

# # # # def receipt(request, token):
# # # #     deposit = get_object_or_404(Deposit, token=token)
# # # #     return render(request, 'vault/receipt.html', {'d': deposit})

# # # # def search(request):
# # # #     q = request.GET.get('q','').strip()
# # # #     results = []
# # # #     if q:
# # # #         results = Deposit.objects.select_related('devotee').filter(
# # # #             Q(token__icontains=q) | Q(devotee__name__icontains=q) | Q(devotee__phone__icontains=q)
# # # #         ).order_by('-received_at')[:50]
# # # #     return render(request, 'vault/search.html', {'q': q, 'results': results})

# # # # def mark_returned(request, token):
# # # #     deposit = get_object_or_404(Deposit, token=token)
# # # #     if request.method == 'POST':
# # # #         deposit.status = 'RETURNED'
# # # #         deposit.returned_at = timezone.now()
# # # #         deposit.save()
# # # #         messages.success(request, f'Returned: {deposit.token}')
# # # #         return redirect('receipt', token=deposit.token)
# # # #     return render(request, 'vault/mark_returned.html', {'d': deposit})

# # # # def report(request):
# # # #     # Filters
# # # #     year = request.GET.get('year')
# # # #     status = request.GET.get('status')
# # # #     qs = Deposit.objects.select_related('devotee').all().order_by('-received_at')
# # # #     if year:
# # # #         qs = qs.filter(diwali_year=year)
# # # #     if status:
# # # #         qs = qs.filter(status=status)

# # # #     # Summary
# # # #     total_amount = qs.aggregate(total=Sum('amount'))['total'] or 0
# # # #     total_count = qs.count()

# # # #     return render(request, 'vault/report.html', { 'qs': qs[:500], 'year': year, 'status': status, 'total_amount': total_amount, 'total_count': total_count })

# # # # def export_csv(request):
# # # #     year = request.GET.get('year')
# # # #     status = request.GET.get('status')
# # # #     qs = Deposit.objects.select_related('devotee').all().order_by('token')
# # # #     if year:
# # # #         qs = qs.filter(diwali_year=year)
# # # #     if status:
# # # #         qs = qs.filter(status=status)

# # # #     response = HttpResponse(content_type='text/csv')
# # # #     response['Content-Disposition'] = 'attachment; filename="deposits.csv"'
# # # #     writer = csv.writer(response)
# # # #     writer.writerow(['Token','Name','Phone','Aadhaar Last4','Amount','Status','Received At','Returned At','Year','Address','Comment','Form Filler Name','Quantity'])
# # # #     for d in qs:
# # # #         writer.writerow([
# # # #             d.token, d.devotee.name, d.devotee.phone, d.devotee.aadhaar_last4,
# # # #             d.amount, d.status, d.received_at, d.returned_at, d.diwali_year, d.devotee.address.replace('\n',' '),
# # # #             d.comment_choice, d.form_filler_name, d.quantity
# # # #         ])
# # # #     return response
# # from django.shortcuts import render, redirect, get_object_or_404
# # from django.http import HttpResponse, JsonResponse
# # from django.contrib import messages
# # from django.utils import timezone
# # from django.db.models import Sum, Q
# # from django.contrib.auth import authenticate, login, logout
# # from django.contrib.auth.decorators import login_required
# # import csv

# # from .forms import IntakeForm
# # from .models import Deposit
# # from .utils import next_token
# # from django.core.mail import send_mail


# # # ---------- Authentication ----------
# # def user_login(request):
# #     if request.method == "POST":
# #         username = request.POST.get('username')
# #         password = request.POST.get('password')
# #         user = authenticate(request, username=username, password=password)
# #         if user:
# #             login(request, user)
# #             return redirect('home')
# #         else:
# #             messages.error(request, "Invalid Username or Password")
# #     return render(request, 'login.html')


# # def user_logout(request):
# #     logout(request)
# #     return redirect('login')


# # # ---------- Deposit Form ----------
# # @login_required(login_url='/login/')
# # # def intake(request):
# # #     if request.method == 'POST':
# # #         form = IntakeForm(request.POST)
# # #         if form.is_valid():
# # #             # Store form data in session instead of saving to DB
# # #             request.session['pending_deposit'] = form.cleaned_data

# # #             # Redirect to OTP page
# # #             return redirect('otp')  # Your OTP view URL name
# # #     else:
# # #         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})

# # #     return render(request, 'vault/intake.html', {'form': form})
# # @login_required(login_url='/login/')
# # def intake(request):
# #     if request.method == 'POST':
# #         form = IntakeForm(request.POST)
# #         if form.is_valid():
# #             # Copy cleaned data
# #             cleaned_data = form.cleaned_data.copy()

# #             # Convert Decimal to string for session storage
# #             if 'amount' in cleaned_data:
# #                 cleaned_data['amount'] = str(cleaned_data['amount'])
# #             if 'quantity' in cleaned_data:
# #                 cleaned_data['quantity'] = str(cleaned_data['quantity'])

# #             # Store in session
# #             request.session['pending_deposit'] = cleaned_data

# #             # Redirect to OTP page
# #             return redirect('otp')
# #     else:
# #         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})

# #     return render(request, 'vault/intake.html', {'form': form})

# # # ---------- OTP Page ----------
# # @login_required(login_url='/login/')
# # def otp(request):
# #     """
# #     Render the front-end MSG91 OTP widget page.
# #     """
# #     context = {
# #         "widget_id": "356a6568356a343732333939",       # Keep secret in settings/env
# #         "token_auth": "472099TjSVarLM2l68e2193bP1"     # Keep secret in settings/env
# #     }
# #     return render(request, "vault/otp_page.html", context)


# # # ---------- OTP Verify ----------
# # @login_required(login_url='/login/')
# # def otp_verify(request):
# #     """
# #     Called via AJAX after front-end OTP verification.
# #     Saves deposit and generates token.
# #     """
# #     if request.method == "POST":
# #         pending = request.session.get('pending_deposit')
# #         if not pending:
# #             return JsonResponse({"error": "No deposit data found."}, status=400)

# #         # Save deposit
# #         deposit = IntakeForm(pending).save(commit=False)
# #         deposit.token = next_token(pending.get('diwali_year', timezone.localdate().year))
# #         deposit.save()

# #         # Optional: send email
# #         if deposit.devotee.email:
# #             try:
# #                 send_mail(
# #                     subject="Mahalakshmi Temple - Token Number",
# #                     message=f"Dear {deposit.devotee.name},\n\n"
# #                             f"Your token number is {deposit.token}.\n"
# #                             f"Amount Deposited: ‚Çπ{deposit.amount}\n"
# #                             f"Year: {deposit.diwali_year}\n\n"
# #                             f"Please keep this safe. Jai Maa Mahalakshmi üôè",
# #                     from_email="your_email@gmail.com",
# #                     recipient_list=[deposit.devotee.email],
# #                     fail_silently=True,
# #                 )
# #             except Exception as e:
# #                 print("Email sending failed:", e)

# #         # Clear session
# #         del request.session['pending_deposit']

# #         # Return JSON with redirect URL
# #         return JsonResponse({"redirect_url": f"/receipt/{deposit.token}/"})

# #     return JsonResponse({"error": "Invalid request."}, status=400)


# # # ---------- Home / Dashboard ----------
# # @login_required(login_url='/login/')
# # def home(request):
# #     total_held = Deposit.objects.filter(status='HELD').aggregate(total=Sum('amount'))['total'] or 0
# #     total_returned = Deposit.objects.filter(status='RETURNED').aggregate(total=Sum('amount'))['total'] or 0
# #     count_today = Deposit.objects.filter(received_at__date=timezone.localdate()).count()
# #     return render(request, 'vault/home.html', {
# #         'total_held': total_held,
# #         'total_returned': total_returned,
# #         'count_today': count_today,
# #     })


# # # ---------- Receipt ----------
# # @login_required(login_url='/login/')
# # def receipt(request, token):
# #     deposit = get_object_or_404(Deposit, token=token)
# #     return render(request, 'vault/receipt.html', {'d': deposit})


# # # ---------- Search ----------
# # @login_required(login_url='/login/')
# # def search(request):
# #     q = request.GET.get('q', '').strip()
# #     results = []
# #     if q:
# #         results = Deposit.objects.select_related('devotee').filter(
# #             Q(token__icontains=q) |
# #             Q(devotee__name__icontains=q) |
# #             Q(devotee__phone__icontains=q)
# #         ).order_by('-received_at')[:50]
# #     return render(request, 'vault/search.html', {'q': q, 'results': results})


# # # ---------- Mark Returned ----------
# # @login_required(login_url='/login/')
# # def mark_returned(request, token):
# #     deposit = get_object_or_404(Deposit, token=token)
# #     if request.method == 'POST':
# #         deposit.status = 'RETURNED'
# #         deposit.returned_at = timezone.now()
# #         deposit.save()
# #         messages.success(request, f'Returned: {deposit.token}')
# #         return redirect('receipt', token=deposit.token)
# #     return render(request, 'vault/mark_returned.html', {'d': deposit})


# # # ---------- Report ----------
# # @login_required(login_url='/login/')
# # def report(request):
# #     year = request.GET.get('year')
# #     status = request.GET.get('status')
# #     qs = Deposit.objects.select_related('devotee').all().order_by('-received_at')
# #     if year:
# #         qs = qs.filter(diwali_year=year)
# #     if status:
# #         qs = qs.filter(status=status)

# #     total_amount = qs.aggregate(total=Sum('amount'))['total'] or 0
# #     total_count = qs.count()

# #     return render(request, 'vault/report.html', {
# #         'qs': qs[:500],
# #         'year': year,
# #         'status': status,
# #         'total_amount': total_amount,
# #         'total_count': total_count
# #     })


# # # ---------- Export CSV ----------
# # @login_required(login_url='/login/')
# # def export_csv(request):
# #     year = request.GET.get('year')
# #     status = request.GET.get('status')
# #     qs = Deposit.objects.select_related('devotee').all().order_by('token')
# #     if year:
# #         qs = qs.filter(diwali_year=year)
# #     if status:
# #         qs = qs.filter(status=status)

# #     response = HttpResponse(content_type='text/csv')
# #     response['Content-Disposition'] = 'attachment; filename="deposits.csv"'
# #     writer = csv.writer(response)
# #     writer.writerow(['Token','Name','Phone','Aadhaar Last4','Amount','Status','Received At',
# #                      'Returned At','Year','Address','Comment','Form Filler Name','Quantity'])
# #     for d in qs:
# #         writer.writerow([
# #             d.token, d.devotee.name, d.devotee.phone, d.devotee.aadhaar_last4,
# #             d.amount, d.status, d.received_at, d.returned_at, d.diwali_year,
# #             d.devotee.address.replace('\n',' '), d.comment_choice, d.form_filler_name,
# #             d.quantity
# #         ])
# #     return response
# from django.shortcuts import render, redirect, get_object_or_404
# from django.http import HttpResponse
# from django.contrib import messages
# from django.utils import timezone
# from django.db.models import Sum, Q
# from django.contrib.auth import authenticate, login, logout
# from django.contrib.auth.decorators import login_required
# import csv

# from .forms import IntakeForm
# from .models import Deposit,Devotee
# from .utils import next_token
# from django.core.mail import send_mail


# # ---------------- Authentication ----------------
# def user_login(request):
#     if request.method == "POST":
#         username = request.POST.get('username')
#         password = request.POST.get('password')
#         user = authenticate(request, username=username, password=password)
#         if user:
#             login(request, user)
#             return redirect('home')
#         else:
#             messages.error(request, "Invalid Username or Password")
#     return render(request, 'login.html')


# def user_logout(request):
#     logout(request)
#     return redirect('login')


# # ---------------- Deposit Intake ----------------
# @login_required(login_url='/login/')
# def intake(request):
#     """
#     Intake form page. Stores data in session and redirects to OTP page.
#     """
#     if request.method == 'POST':
#         form = IntakeForm(request.POST)
#         if form.is_valid():
#             # Copy cleaned data and convert Decimal to str for session
#             cleaned_data = form.cleaned_data.copy()
#             if 'amount' in cleaned_data:
#                 cleaned_data['amount'] = str(cleaned_data['amount'])
#             if 'quantity' in cleaned_data:
#                 cleaned_data['quantity'] = str(cleaned_data['quantity'])

#             # Store in session
#             request.session['pending_deposit'] = cleaned_data

#             # Redirect to OTP page
#             return redirect('otp')
#     else:
#         form = IntakeForm(initial={'diwali_year': timezone.localdate().year})

#     return render(request, 'vault/intake.html', {'form': form})


# # ---------------- OTP Page ----------------
# @login_required(login_url='/login/')
# def otp(request):
#     """
#     Render MSG91 OTP widget page.
#     """
#     context = {
#         "widget_id": "356a6568356a343732333939",       # Secret, put in settings/env
#         "token_auth": "472099TjSVarLM2l68e2193bP1"     # Secret, put in settings/env
#     }
#     return render(request, "vault/otp_page.html", context)


# # ---------------- OTP Verification ----------------
# @login_required(login_url='/login/')
# @login_required(login_url='/login/')
# @login_required(login_url='/login/')
# def otp_verify(request):
#     """
#     Called after MSG91 OTP verification.
#     Saves deposit, generates token, sends email, redirects to receipt.
#     """
#     pending = request.session.get('pending_deposit')
#     if not pending:
#         messages.error(request, "No deposit data found. Please fill the form again.")
#         return redirect('intake')

#     # Get or create the devotee
#     phone = pending.get('phone')
#     name = pending.get('name')
#     aadhaar_last4 = pending.get('aadhaar_last4', '')
#     address = pending.get('address', '')

#     devotee, created = Devotee.objects.get_or_create(
#         phone=phone,
#         defaults={
#             'name': name,
#             'aadhaar_last4': aadhaar_last4,
#             'address': address,
#         }
#     )

#     # Create Deposit
#     deposit = Deposit()
#     deposit.devotee = devotee
#     deposit.amount = pending.get('amount')
#     deposit.quantity = pending.get('quantity')
#     deposit.comment_choice = pending.get('comment_choice', '')
#     deposit.form_filler_name = pending.get('form_filler_name', '')
#     deposit.diwali_year = pending.get('diwali_year', timezone.localdate().year)
#     deposit.received_at = timezone.now()
#     deposit.status = 'HELD'
#     deposit.token = next_token(deposit.diwali_year)
#     deposit.save()

#     # Optional: send email
#     if devotee.email:
#         try:
#             send_mail(
#                 subject="Mahalakshmi Temple - Token Number",
#                 message=f"Dear {devotee.name},\n\n"
#                         f"Your token number is {deposit.token}.\n"
#                         f"Amount Deposited: ‚Çπ{deposit.amount}\n"
#                         f"Year: {deposit.diwali_year}\n\n"
#                         f"Please keep this safe. Jai Maa Mahalakshmi üôè",
#                 from_email="your_email@gmail.com",
#                 recipient_list=[devotee.email],
#                 fail_silently=True,
#             )
#         except Exception as e:
#             print("Email sending failed:", e)

#     # Clear session
#     del request.session['pending_deposit']

#     # Redirect to receipt page
#     return redirect('receipt', token=deposit.token)
#     """
#     Called after MSG91 OTP verification.
#     Saves deposit, generates token, sends email, redirects to receipt.
#     """
#     pending = request.session.get('pending_deposit')
#     if not pending:
#         messages.error(request, "No deposit data found. Please fill the form again.")
#         return redirect('intake')

#     # Manually create Deposit instance
#     deposit = Deposit()
#     deposit.devotee_id = pending.get('devotee')   # adjust according to your form
#     deposit.amount = pending.get('amount')
#     deposit.quantity = pending.get('quantity')
#     deposit.comment_choice = pending.get('comment_choice', '')
#     deposit.form_filler_name = pending.get('form_filler_name', '')
#     deposit.diwali_year = pending.get('diwali_year', timezone.localdate().year)
#     deposit.received_at = timezone.now()
#     deposit.status = 'HELD'
#     deposit.token = next_token(deposit.diwali_year)
#     deposit.save()

#     # Optional: send email
#     if deposit.devotee.email:
#         try:
#             send_mail(
#                 subject="Mahalakshmi Temple - Token Number",
#                 message=f"Dear {deposit.devotee.name},\n\n"
#                         f"Your token number is {deposit.token}.\n"
#                         f"Amount Deposited: ‚Çπ{deposit.amount}\n"
#                         f"Year: {deposit.diwali_year}\n\n"
#                         f"Please keep this safe. Jai Maa Mahalakshmi üôè",
#                 from_email="your_email@gmail.com",
#                 recipient_list=[deposit.devotee.email],
#                 fail_silently=True,
#             )
#         except Exception as e:
#             print("Email sending failed:", e)

#     # Clear session
#     del request.session['pending_deposit']

#     # Redirect to receipt page
#     return redirect('receipt', token=deposit.token)

#     """
#     Called after MSG91 OTP verification.
#     Saves deposit, generates token, sends email, redirects to receipt.
#     """
#     pending = request.session.get('pending_deposit')
#     if not pending:
#         messages.error(request, "No deposit data found. Please fill the form again.")
#         return redirect('intake')

#     # Save deposit
#     deposit = IntakeForm(pending).save(commit=False)
#     deposit.token = next_token(pending.get('diwali_year', timezone.localdate().year))
#     deposit.save()

#     # Optional: send email
#     if deposit.devotee.email:
#         try:
#             send_mail(
#                 subject="Mahalakshmi Temple - Token Number",
#                 message=f"Dear {deposit.devotee.name},\n\n"
#                         f"Your token number is {deposit.token}.\n"
#                         f"Amount Deposited: ‚Çπ{deposit.amount}\n"
#                         f"Year: {deposit.diwali_year}\n\n"
#                         f"Please keep this safe. Jai Maa Mahalakshmi üôè",
#                 from_email="your_email@gmail.com",
#                 recipient_list=[deposit.devotee.email],
#                 fail_silently=True,
#             )
#         except Exception as e:
#             print("Email sending failed:", e)

#     # Clear session
#     del request.session['pending_deposit']

#     # Redirect to receipt page
#     return redirect('receipt', token=deposit.token)


# # ---------------- Dashboard ----------------
# @login_required(login_url='/login/')
# def home(request):
#     total_held = Deposit.objects.filter(status='HELD').aggregate(total=Sum('amount'))['total'] or 0
#     total_returned = Deposit.objects.filter(status='RETURNED').aggregate(total=Sum('amount'))['total'] or 0
#     count_today = Deposit.objects.filter(received_at__date=timezone.localdate()).count()
#     return render(request, 'vault/home.html', {
#         'total_held': total_held,
#         'total_returned': total_returned,
#         'count_today': count_today,
#     })


# # ---------------- Receipt ----------------
# @login_required(login_url='/login/')
# def receipt(request, token):
#     deposit = get_object_or_404(Deposit, token=token)
#     return render(request, 'vault/receipt.html', {'d': deposit})


# # ---------------- Search ----------------
# @login_required(login_url='/login/')
# def search(request):
#     q = request.GET.get('q', '').strip()
#     results = []
#     if q:
#         results = Deposit.objects.select_related('devotee').filter(
#             Q(token__icontains=q) |
#             Q(devotee__name__icontains=q) |
#             Q(devotee__phone__icontains=q)
#         ).order_by('-received_at')[:50]
#     return render(request, 'vault/search.html', {'q': q, 'results': results})


# # ---------------- Mark Returned ----------------
# @login_required(login_url='/login/')
# def mark_returned(request, token):
#     deposit = get_object_or_404(Deposit, token=token)
#     if request.method == 'POST':
#         deposit.status = 'RETURNED'
#         deposit.returned_at = timezone.now()
#         deposit.save()
#         messages.success(request, f'Returned: {deposit.token}')
#         return redirect('receipt', token=deposit.token)
#     return render(request, 'vault/mark_returned.html', {'d': deposit})


# # ---------------- Report ----------------
# @login_required(login_url='/login/')
# def report(request):
#     year = request.GET.get('year')
#     status = request.GET.get('status')
#     qs = Deposit.objects.select_related('devotee').all().order_by('-received_at')
#     if year:
#         qs = qs.filter(diwali_year=year)
#     if status:
#         qs = qs.filter(status=status)

#     total_amount = qs.aggregate(total=Sum('amount'))['total'] or 0
#     total_count = qs.count()

#     return render(request, 'vault/report.html', {
#         'qs': qs[:500],
#         'year': year,
#         'status': status,
#         'total_amount': total_amount,
#         'total_count': total_count
#     })


# # ---------------- Export CSV ----------------
# @login_required(login_url='/login/')
# def export_csv(request):
#     year = request.GET.get('year')
#     status = request.GET.get('status')
#     qs = Deposit.objects.select_related('devotee').all().order_by('token')
#     if year:
#         qs = qs.filter(diwali_year=year)
#     if status:
#         qs = qs.filter(status=status)

#     response = HttpResponse(content_type='text/csv')
#     response['Content-Disposition'] = 'attachment; filename="deposits.csv"'
#     writer = csv.writer(response)
#     writer.writerow([
#         'Token','Name','Phone','Aadhaar Last4','Amount','Status','Received At',
#         'Returned At','Year','Address','Comment','Form Filler Name','Quantity'
#     ])
#     for d in qs:
#         writer.writerow([
#             d.token, d.devotee.name, d.devotee.phone, d.devotee.aadhaar_last4,
#             d.amount, d.status, d.received_at, d.returned_at, d.diwali_year,
#             d.devotee.address.replace('\n',' '), d.comment_choice, d.form_filler_name,
#             d.quantity
#         ])
#     return response
from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse
from django.contrib import messages
from django.utils import timezone
from django.db.models import Sum, Q
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.core.mail import send_mail
import csv

from .forms import IntakeForm
from .models import Deposit, Devotee
from .utils import next_token

# ---------- Authentication ----------
def user_login(request):
    if request.method == "POST":
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        if user:
            login(request, user)
            return redirect('home')
        else:
            messages.error(request, "Invalid Username or Password")
    return render(request, 'login.html')

def user_logout(request):
    logout(request)
    return redirect('login')


# ---------- Deposit Form ----------
@login_required(login_url='/login/')
def intake(request):
    if request.method == 'POST':
        form = IntakeForm(request.POST)
        if form.is_valid():
            # Store cleaned data in session (Decimal -> str)
            cleaned_data = form.cleaned_data.copy()
            if 'amount' in cleaned_data:
                cleaned_data['amount'] = str(cleaned_data['amount'])
            if 'quantity' in cleaned_data:
                cleaned_data['quantity'] = str(cleaned_data['quantity'])
            request.session['pending_deposit'] = cleaned_data

            # Redirect to OTP page
            return redirect('otp')
    else:
        form = IntakeForm(initial={'diwali_year': timezone.localdate().year})

    return render(request, 'vault/intake.html', {'form': form})


# ---------- OTP Page ----------
@login_required(login_url='/login/')
def otp(request):
    context = {
        "widget_id": "356a6568356a343732333939",
        "token_auth": "472099TjSVarLM2l68e2193bP1"
    }
    return render(request, "vault/otp_page.html", context)


# ---------- OTP Verify ----------
@login_required(login_url='/login/')
def otp_verify(request):
    pending = request.session.get('pending_deposit')
    if not pending:
        messages.error(request, "No deposit data found. Please fill the form first.")
        return redirect('intake')

    # Create or fetch Devotee
    devotee, created = Devotee.objects.get_or_create(
        name=pending.get('devotee_name'),
        phone=pending.get('phone'),
        defaults={
            'email': pending.get('email', ''),
            'aadhaar_last4': pending.get('aadhaar_last4', ''),
            'address': pending.get('address', '')
        }
    )

    # Create Deposit
    deposit = Deposit(
        devotee=devotee,
        amount=pending.get('amount'),
        diwali_year=pending.get('diwali_year', timezone.localdate().year),
        comment_choice=pending.get('comment_choice', ''),
        form_filler_name=pending.get('form_filler_name', ''),
        quantity=pending.get('quantity', 1),
        token=next_token(pending.get('diwali_year', timezone.localdate().year))
    )
    deposit.save()

    # Send email if available
    if devotee.email:
        try:
            send_mail(
                subject="Mahalakshmi Temple - Token Number",
                message=f"Dear {devotee.name},\n\n"
                        f"Your token number is {deposit.token}.\n"
                        f"Amount Deposited: ‚Çπ{deposit.amount}\n"
                        f"Year: {deposit.diwali_year}\n\n"
                        f"Please keep this safe. Jai Maa Mahalakshmi üôè",
                from_email="your_email@gmail.com",
                recipient_list=[devotee.email],
                fail_silently=True,
            )
        except Exception as e:
            print("Email sending failed:", e)

    # Clear session
    del request.session['pending_deposit']

    # Redirect to receipt page
    return redirect('receipt', token=deposit.token)


# ---------- Home / Dashboard ----------
@login_required(login_url='/login/')
def home(request):
    total_held = Deposit.objects.filter(status='HELD').aggregate(total=Sum('amount'))['total'] or 0
    total_returned = Deposit.objects.filter(status='RETURNED').aggregate(total=Sum('amount'))['total'] or 0
    count_today = Deposit.objects.filter(received_at__date=timezone.localdate()).count()
    return render(request, 'vault/home.html', {
        'total_held': total_held,
        'total_returned': total_returned,
        'count_today': count_today,
    })


# ---------- Receipt ----------
@login_required(login_url='/login/')
def receipt(request, token):
    deposit = get_object_or_404(Deposit, token=token)
    return render(request, 'vault/receipt.html', {'d': deposit})


@login_required(login_url='/login/')
def search(request):
    q = request.GET.get('q', '').strip()
    results = []
    if q:
        results = Deposit.objects.select_related('devotee').filter(
            Q(token__icontains=q) |
            Q(devotee__name__icontains=q) |
            Q(devotee__phone__icontains=q)
        ).order_by('-received_at')[:50]
    return render(request, 'vault/search.html', {'q': q, 'results': results})

@login_required(login_url='/login/')
def mark_returned(request, token):
    deposit = get_object_or_404(Deposit, token=token)
    if request.method == 'POST':
        deposit.status = 'RETURNED'
        deposit.returned_at = timezone.now()
        deposit.save()
        messages.success(request, f'Returned: {deposit.token}')
        return redirect('receipt', token=deposit.token)
    return render(request, 'vault/mark_returned.html', {'d': deposit})


# ---------------- Report ----------------
@login_required(login_url='/login/')
def report(request):
    year = request.GET.get('year')
    status = request.GET.get('status')
    qs = Deposit.objects.select_related('devotee').all().order_by('-received_at')
    if year:
        qs = qs.filter(diwali_year=year)
    if status:
        qs = qs.filter(status=status)

    total_amount = qs.aggregate(total=Sum('amount'))['total'] or 0
    total_count = qs.count()

    return render(request, 'vault/report.html', {
        'qs': qs[:500],
        'year': year,
        'status': status,
        'total_amount': total_amount,
        'total_count': total_count
    })


# ---------------- Export CSV ----------------
@login_required(login_url='/login/')
def export_csv(request):
    year = request.GET.get('year')
    status = request.GET.get('status')
    qs = Deposit.objects.select_related('devotee').all().order_by('token')
    if year:
        qs = qs.filter(diwali_year=year)
    if status:
        qs = qs.filter(status=status)

    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="deposits.csv"'
    writer = csv.writer(response)
    writer.writerow([
        'Token','Name','Phone','Aadhaar Last4','Amount','Status','Received At',
        'Returned At','Year','Address','Comment','Form Filler Name','Quantity'
    ])
    for d in qs:
        writer.writerow([
            d.token, d.devotee.name, d.devotee.phone, d.devotee.aadhaar_last4,
            d.amount, d.status, d.received_at, d.returned_at, d.diwali_year,
            d.devotee.address.replace('\n',' '), d.comment_choice, d.form_filler_name,
            d.quantity
        ])
    return response
# from django.shortcuts import render, redirect, get_object_or_404